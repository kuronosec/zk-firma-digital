import subprocess
import os
import sys
from zkpy.ptau import PTau
import zkpy.utils as utils

GROTH = "groth16"
PLONK = "plonk"
FFLONK = "fflonk"


class Circuit:
    """
    Manages compiling, proving, and verifying Circom circuits.

    Args:
        circ_file (str): Path to a circom circuit file.
        output_dir (str, optional): Path to where generated files should be outputted. Defaults to the current directory.
        working_dir (str, optional): Path that all given file paths are relative to. Defaults to the current directory
        r1cs (str, optional): Optional path to a pre-generated r1cs file.
        sym_file (str, optional): Optional path to a pre-generated symbols file.
        js_dir (str, optional): Optional path to a pre-generated directory with JS files.
        wasm (str, optional): Optional path to a pre-generated wasm file.
        witness (str, optional): Optional path to a witness file.
        zkey (str, optional): Optional path to a pre-generated zkey file.
        vkey (str, optional): Optional path to a pre-generated verification key file.

    Attributes:
        circ_file (str): Path to a circom circuit file. This circuit can be compiled, proved, etc. with this class.
        output_dir (str): Path to where generated files will be outputted.
        working_dir (str): Specifies the path that all given file paths are relative to.
        r1cs_file (str): Path to an r1cs file. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated
        sym_file (str): Path to a symbols file. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated
        js_dir (str): Path to the JS directory generated by SnarkJS. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated
        wasm_file (str): Path to a wasm file. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated
        zkey (str): Path to a zkey file. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated
        vkey (str): Path to a verification key file. This can be generated by the class itself when a circuit is compiled, or the path can be given if already generated

    """

    def __init__(
        self,
        circ_file,
        output_dir="./",
        working_dir="./",
        node_module_dir=None,
        r1cs=None,
        sym_file=None,
        js_dir=None,
        wasm=None,
        witness=None,
        zkey=None,
        vkey=None
    ):
        self.circ_file = circ_file
        self.node_modules_dir = node_module_dir
        self.output_dir = output_dir
        self.working_dir = working_dir
        self.r1cs_file = r1cs
        self.sym_file = sym_file
        self.js_dir = js_dir
        self.wasm_file = wasm
        self.wtns_file = witness
        self.zkey_file = zkey
        self.vkey_file = vkey

        base_dir = os.path.dirname(sys.executable)
        snarkjs_dir = base_dir

        # Add this directory to the PATH environment variable.
        os.environ["PATH"] = snarkjs_dir + os.pathsep + os.environ.get("PATH", "")

        # Check what operation system we re running on
        self.snarkjs_command = "snarkjs"
        if os.name == 'nt':
            self.snarkjs_command = "snarkjs.cmd"

    def compile(self):
        """Compiles the circuit and generates an r1cs file, a symbols file, a wasm file, and a js dir"""

        proc = subprocess.run(
            ["circom", self.circ_file, "--r1cs", "--sym", "--wasm",
             '-o', self.output_dir, '-l' , self.node_modules_dir],
            capture_output=True,
            cwd=self.working_dir,
            text=True
        )
        print(proc.stdout)
        self.r1cs_file = utils.get_r1cs_file(self.circ_file, self.output_dir)
        self.sym_file = utils.get_sym_file(self.circ_file, self.output_dir)
        self.wasm_file = utils.get_wasm_file(self.circ_file, self.output_dir)
        self.js_dir = utils.get_js_dir(self.circ_file, self.output_dir)

    def check_circ_compiled(self):
        """Checks that the circuit was compiled and that the relevant files exist"""
        if self.r1cs_file is None or not utils.exists(self.r1cs_file):
            print(f"r1cs file {self.r1cs_file} does not exist.")
            return False
        if self.sym_file is None or not utils.exists(self.sym_file):
            print(f"sym file {self.sym_file} does not exist.")
            return False
        if self.wasm_file is None or not utils.exists(self.wasm_file):
            print(f"wasm file {self.wasm_file} does not exist.")
            return False
        if self.js_dir is None or not utils.exists(self.js_dir):
            print(f"js dir {self.js_dir} does not exist")
            return False
        return True

    def get_info(self):
        """Prints info about the circuit. Requires that the circuit was compiled first."""
        if self.r1cs_file is None or not utils.exists(self.r1cs_file):
            raise ValueError(f"r1cs file {self.r1cs_file} does not exist.")
        proc = subprocess.run(
            [self.snarkjs_command, "r1cs", "info", self.r1cs_file], capture_output=True, cwd=self.working_dir, check=True
        )
        return proc.stdout.decode()

    def print_constraints(self):
        """Prints info about the constraints of the circuit. Requires that the circuit was compiled first."""
        if self.r1cs_file is None or not utils.exists(self.r1cs_file):
            raise ValueError(f"r1cs file {self.r1cs_file} does not exist.")
        if self.sym_file is None or not utils.exists(self.sym_file):
            raise ValueError(f"sym file {self.sym_file} does not exist.")
        proc = subprocess.run(
            [self.snarkjs_command, "r1cs", "print", self.r1cs_file, self.sym_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        return proc.stdout.decode()

    def export_r1cs_to_json(self):
        """Exports the r1cs file as a JSON file."""
        if self.r1cs_file is None or not utils.exists(self.r1cs_file):
            raise ValueError(f"r1cs file {self.r1cs_file} does not exist.")
        json_output_file = utils.get_r1cs_file(self.circ_file, self.output_dir) + '.json'
        proc = subprocess.run(
            [self.snarkjs_command, "r1cs", "export", "json", self.r1cs_file, json_output_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        if proc.returncode == 1:
            raise ValueError(proc.stderr.decode('utf-8'))
        return json_output_file

    def gen_witness(self, input_file, output_file=None):
        """Generates a witness file. Requires that the circuit was compiled first.

        Args:
            input_file (str): Path to an input json file that specifies the inputs to the circuit.
            output_file (str): Path of where the witness file should be outputted. Defaults to a randomly generated file name.
        """
        if output_file is None:
            output_file = os.path.join(self.output_dir, "witness.wtns")
        if self.wasm_file is None and self.js_dir is not None:
            self.wasm_file = os.path.join(self.output_dir, utils.get_wasm_file(self.circ_file, self.output_dir))
        gen_wtns_file = os.path.join(self.js_dir, "generate_witness.js")
        proc = subprocess.run(
            ["node", gen_wtns_file, self.wasm_file, input_file, output_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        if proc.returncode != 0:
            raise ValueError(proc.stderr('utf-8'))
        print(proc.stdout.decode('utf-8'))
        print(proc.stderr.decode('utf-8'))
        self.wtns_file = output_file

    # Sets up to generate proof. Scheme = proving scheme, ptau = previous powers of tau ceremony
    def setup(self, scheme, ptau, output_file=None):
        """Prepares to generate proof and creates a zkey file.

        Args:
            scheme (str): The proving scheme to use. Can either be `GROTH`, `PLONK`, or `FFLONK`.
            ptau (PTau): A `PTau` object with a completed powers of tau ceremony.
            output_file (str): Path of where the zkey file should be outputted. Defaults to a randomly generated file name.
        """
        if output_file is None:
            output_file = os.path.join(self.output_dir, utils.gen_rand_zkey_file())
        if scheme != PLONK and scheme != FFLONK and scheme != GROTH:
            raise ValueError("scheme must either be 'plonk', 'fflonk', or 'groth16'")
        proc = subprocess.run(
            [self.snarkjs_command, scheme, "setup", self.r1cs_file, ptau.ptau_file, output_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        print(proc.stdout.decode('utf-8'))
        self.zkey_file = output_file

    def contribute_phase2(self, entropy="", output_file=None):
        """Contributes to phase 2. Required for the Groth16 proving scheme. The circuit must have been previously setup.

        Args:
            entropy (str): Random entropy to contribute to the zkey.
            output_file (str, optional): Path of where the zkey file should be outputted. Defaults to a randomly generated file name.
        """
        if output_file is None:
            output_file = os.path.join(self.output_dir, utils.gen_rand_zkey_file())
        proc = subprocess.run(
            [
                self.snarkjs_command,
                "zkey",
                "contribute",
                self.zkey_file,
                output_file,
                "-v",
                f'-e={entropy}',
            ],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        print(proc.stdout.decode('utf-8'))
        self.zkey_file = output_file

    def prove(self, scheme, proof_out=None, public_out=None):
        """Generates a proof for the circuit.

        Args:
            scheme (str): The proving scheme to use. Can either be `GROTH`, `PLONK`, or `FFLONK`.
            proof_out (str, optional): Path of where the proof file should be outputted. Defaults to 'proof.json'.
            public_out (str, optional): Path of where the public file should be outputted. Defaults to 'public.json'.
        """
        if proof_out is None:
            proof_out = os.path.join(self.output_dir, "proof.json")
        if public_out is None:
            public_out = os.path.join(self.output_dir, "public.json")
        proc = subprocess.run(
            [self.snarkjs_command, scheme, "prove",
            self.zkey_file, self.wtns_file, proof_out, public_out],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        self.proof_file = proof_out
        self.public_file = public_out
        print(proc.stdout.decode('utf-8'))

    def verify_zkey(self, ptau, zkey_file=None):
        """Verifies a zkey is valid.

        Args:
            ptau (PTau): A powers of tau ceremony.
            zkey_file (str, optional): Path to the zkey file to verify. Defaults to a previously generated zkey.
        """
        if zkey_file is None:
            zkey_file = self.zkey_file
        proc = subprocess.run(
            [self.snarkjs_command, "zkey", "verify",
              self.r1cs_file, ptau.ptau_file, zkey_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        print(proc.stdout.decode('utf-8'))
        if proc.stderr:
            return False
        else:
            return True

    def export_vkey(self, zkey_file=None, output_file=None):
        """Exports a verification key.

        Args:
            zkey_file (str, optional): Path to a zkey file from which the verification key should be created. Defaults to a previously generated zkey.
            output_file (str, optional): Path to where the verification key file should be outputted. Defaults to a randomly generated file name.
        """
        if zkey_file is None:
            zkey_file = self.zkey_file
        if output_file is None:
            output_file = os.path.join(self.output_dir, utils.gen_rand_filename() + '.json')
        subprocess.run(
            [self.snarkjs_command, "zkey", "export", "verificationkey",
             zkey_file, output_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        self.vkey_file = output_file

    def verify(self, scheme, vkey_file=None, public_file=None, proof_file=None):
        """Verifies that a proof is valid.

        Args:
            vkey_file (str, optional): Path to a verification key file. Defaults to a previously generated vkey.
            public_file (str, optional): Path to a public file. Defaults to a previously generated public_file.
            proof_file (str, optional): Path to the proof. Defaults to a previously generated proof.

        Returns:
            bool: Whether the proof is valid or not.
        """
        if vkey_file is None:
            vkey_file = self.vkey_file
        if public_file is None:
            public_file = self.public_file
        if proof_file is None:
            proof_file = self.proof_file
        proc = subprocess.run(
            [self.snarkjs_command, scheme, "verify",
             vkey_file, public_file, proof_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        print(proc.stdout.decode('utf-8'))
        if proc.stderr:
            return False
        else:
            return True

    def fullprove(self, scheme, input_file):
        """Convenience function that handles proving a circuit in its entirety. Performs PTau ceremony, compiles circuit, and proves it.

        Args:
            scheme (str): The proving scheme to use. Can either be `GROTH`, `PLONK`, or `FFLONK`.
            input_file (str): Path to an input json file that specifies the inputs to the circuit.
        """
        ptau = PTau(working_dir=self.working_dir)
        ptau.start()
        ptau.contribute()
        ptau.beacon()
        ptau.prep_phase2()
        ptau.verify()

        self.compile()
        self.gen_witness(input_file)
        self.setup(scheme, ptau)
        self.prove(scheme)
        self.export_vkey()
        self.verify(scheme)

    def export_sol(self, output_file):
        """Convenience function that handles proving a circuit in its entirety. Performs PTau ceremony, compiles circuit, and proves it.

        Args:
            scheme (str): The proving scheme to use. Can either be `GROTH`, `PLONK`, or `FFLONK`.
            input_file (str): Path to an input json file that specifies the inputs to the circuit.
        """
        if self.zkey_file is None or not utils.exists(self.zkey_file):
            raise ValueError(f"zkey file {self.zkey_file} does not exist")
        proc = subprocess.run(
            [self.snarkjs_command, "zkey", "export", "solidityverifier",
             self.zkey_file, output_file],
            capture_output=True,
            cwd=self.working_dir,
            check=True,
        )
        if proc.returncode == 1:
            raise ValueError(proc.stderr.decode('utf-8'))


if __name__ == "__main__":
    ptau = PTau(working_dir="./tmp")
    print("Starting powers of tau")
    ptau.start()
    print("Contribute")
    ptau.contribute()
    print("Beacon")
    ptau.beacon()
    print("Phase2")
    ptau.prep_phase2()
    print("Verify")
    ptau.verify()
    print(ptau.ptau_file)

    circuit = Circuit("./example_circuits/circom.circom", output_dir="./tmp")
    circuit.compile()
    circuit.get_info()
    circuit.print_constraints()
    circuit.gen_witness("./example_circuits/input.json")
    circuit.setup("plonk", ptau)
    circuit.prove("plonk")
    circuit.export_vkey()
    circuit.verify("plonk")
